/**
 * Generated by orval v7.21.0 ðŸº
 * Do not edit manually.
 * Durable Streams API
 * Durable Streams on Cloudflare â€” append-only event streams with pub/sub fan-out.
 * OpenAPI spec version: 0.8.0
 */
export type GetV1ConfigByProjectId200 = {
  corsOrigins: string[];
  isPublic: boolean;
  signingSecrets: string[];
};

export type GetV1ConfigByProjectId401Code =
  (typeof GetV1ConfigByProjectId401Code)[keyof typeof GetV1ConfigByProjectId401Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1ConfigByProjectId401Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1ConfigByProjectId401 = {
  code: GetV1ConfigByProjectId401Code;
  error: string;
};

export type GetV1ConfigByProjectId403Code =
  (typeof GetV1ConfigByProjectId403Code)[keyof typeof GetV1ConfigByProjectId403Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1ConfigByProjectId403Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1ConfigByProjectId403 = {
  code: GetV1ConfigByProjectId403Code;
  error: string;
};

export type GetV1ConfigByProjectId404Code =
  (typeof GetV1ConfigByProjectId404Code)[keyof typeof GetV1ConfigByProjectId404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1ConfigByProjectId404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1ConfigByProjectId404 = {
  code: GetV1ConfigByProjectId404Code;
  error: string;
};

export type PutV1ConfigByProjectIdBody = {
  /** @minItems 1 */
  signingSecrets: string[];
  corsOrigins?: string[];
  isPublic?: boolean;
};

export type PutV1ConfigByProjectId200 = {
  ok: boolean;
};

export type PutV1ConfigByProjectId401Code =
  (typeof PutV1ConfigByProjectId401Code)[keyof typeof PutV1ConfigByProjectId401Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutV1ConfigByProjectId401Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PutV1ConfigByProjectId401 = {
  code: PutV1ConfigByProjectId401Code;
  error: string;
};

export type PutV1ConfigByProjectId403Code =
  (typeof PutV1ConfigByProjectId403Code)[keyof typeof PutV1ConfigByProjectId403Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutV1ConfigByProjectId403Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PutV1ConfigByProjectId403 = {
  code: PutV1ConfigByProjectId403Code;
  error: string;
};

export type GetV1ProjectsByProjectIdStreams200Item0 = {
  createdAt: number;
  streamId: string;
};

export type GetV1StreamsByStreamIdInspect200 = {
  closed: boolean;
  contentType: string;
  public: boolean;
  streamId: string;
  tailOffset: number;
  closedAt?: number;
  createdAt?: number;
  expiresAt?: number;
  ttlSeconds?: number;
};

export type GetV1StreamsByStreamIdInspect404Code =
  (typeof GetV1StreamsByStreamIdInspect404Code)[keyof typeof GetV1StreamsByStreamIdInspect404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1StreamsByStreamIdInspect404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1StreamsByStreamIdInspect404 = {
  code: GetV1StreamsByStreamIdInspect404Code;
  error: string;
};

export type PostV1EstuarySubscribeByEstuaryPathBody = {
  /** @minLength 1 */
  estuaryId: string;
};

export type PostV1EstuarySubscribeByEstuaryPath200 = {
  estuaryId: string;
  estuaryStreamPath: string;
  expiresAt: number;
  isNewEstuary: boolean;
  streamId: string;
};

export type DeleteV1EstuarySubscribeByEstuaryPathBody = {
  /** @minLength 1 */
  estuaryId: string;
};

export type DeleteV1EstuarySubscribeByEstuaryPath200 = {
  success: "true";
};

export type GetV1EstuaryByEstuaryPath200ContentType = string | null;

export type GetV1EstuaryByEstuaryPath200SubscriptionsItem = {
  streamId: string;
};

export type GetV1EstuaryByEstuaryPath200 = {
  contentType: GetV1EstuaryByEstuaryPath200ContentType;
  estuaryId: string;
  estuaryStreamPath: string;
  subscriptions: GetV1EstuaryByEstuaryPath200SubscriptionsItem[];
};

export type DeleteV1EstuaryByEstuaryPath200 = {
  deleted: "true";
  estuaryId: string;
};

export type PutV1StreamByStreamPath409Code =
  (typeof PutV1StreamByStreamPath409Code)[keyof typeof PutV1StreamByStreamPath409Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutV1StreamByStreamPath409Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PutV1StreamByStreamPath409 = {
  code: PutV1StreamByStreamPath409Code;
  error: string;
};

export type PostV1StreamByStreamPath404Code =
  (typeof PostV1StreamByStreamPath404Code)[keyof typeof PostV1StreamByStreamPath404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostV1StreamByStreamPath404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PostV1StreamByStreamPath404 = {
  code: PostV1StreamByStreamPath404Code;
  error: string;
};

export type PostV1StreamByStreamPath409Code =
  (typeof PostV1StreamByStreamPath409Code)[keyof typeof PostV1StreamByStreamPath409Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostV1StreamByStreamPath409Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PostV1StreamByStreamPath409 = {
  code: PostV1StreamByStreamPath409Code;
  error: string;
};

export type PostV1StreamByStreamPath413Code =
  (typeof PostV1StreamByStreamPath413Code)[keyof typeof PostV1StreamByStreamPath413Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostV1StreamByStreamPath413Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PostV1StreamByStreamPath413 = {
  code: PostV1StreamByStreamPath413Code;
  error: string;
};

export type GetV1StreamByStreamPath404Code =
  (typeof GetV1StreamByStreamPath404Code)[keyof typeof GetV1StreamByStreamPath404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1StreamByStreamPath404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1StreamByStreamPath404 = {
  code: GetV1StreamByStreamPath404Code;
  error: string;
};

export type DeleteV1StreamByStreamPath404Code =
  (typeof DeleteV1StreamByStreamPath404Code)[keyof typeof DeleteV1StreamByStreamPath404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeleteV1StreamByStreamPath404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type DeleteV1StreamByStreamPath404 = {
  code: DeleteV1StreamByStreamPath404Code;
  error: string;
};

/**
 * Returns 200 OK if the worker is running.
 * @summary Health check
 */
export type getHealthResponse200 = {
  data: string;
  status: 200;
};

export type getHealthResponseSuccess = getHealthResponse200 & {
  headers: Headers;
};

export type getHealthResponse = getHealthResponseSuccess;

export const getGetHealthUrl = () => {
  return `http://localhost:8787/health`;
};

export const getHealth = async (options?: RequestInit): Promise<getHealthResponse> => {
  const res = await fetch(getGetHealthUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getHealthResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getHealthResponse;
};

/**
 * Retrieve signing secrets, CORS origins, and public flag for a project. Requires a manage-scope JWT.
 * @summary Get project configuration
 */
export type getV1ConfigByProjectIdResponse200 = {
  data: GetV1ConfigByProjectId200;
  status: 200;
};

export type getV1ConfigByProjectIdResponse401 = {
  data: GetV1ConfigByProjectId401;
  status: 401;
};

export type getV1ConfigByProjectIdResponse403 = {
  data: GetV1ConfigByProjectId403;
  status: 403;
};

export type getV1ConfigByProjectIdResponse404 = {
  data: GetV1ConfigByProjectId404;
  status: 404;
};

export type getV1ConfigByProjectIdResponseSuccess = getV1ConfigByProjectIdResponse200 & {
  headers: Headers;
};
export type getV1ConfigByProjectIdResponseError = (
  | getV1ConfigByProjectIdResponse401
  | getV1ConfigByProjectIdResponse403
  | getV1ConfigByProjectIdResponse404
) & {
  headers: Headers;
};

export type getV1ConfigByProjectIdResponse =
  | getV1ConfigByProjectIdResponseSuccess
  | getV1ConfigByProjectIdResponseError;

export const getGetV1ConfigByProjectIdUrl = (projectId: string) => {
  return `http://localhost:8787/v1/config/${projectId}`;
};

export const getV1ConfigByProjectId = async (
  projectId: string,
  options?: RequestInit,
): Promise<getV1ConfigByProjectIdResponse> => {
  const res = await fetch(getGetV1ConfigByProjectIdUrl(projectId), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getV1ConfigByProjectIdResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getV1ConfigByProjectIdResponse;
};

/**
 * Set signing secrets, CORS origins, and public flag for a project. Requires a manage-scope JWT.
 * @summary Update project configuration
 */
export type putV1ConfigByProjectIdResponse200 = {
  data: PutV1ConfigByProjectId200;
  status: 200;
};

export type putV1ConfigByProjectIdResponse401 = {
  data: PutV1ConfigByProjectId401;
  status: 401;
};

export type putV1ConfigByProjectIdResponse403 = {
  data: PutV1ConfigByProjectId403;
  status: 403;
};

export type putV1ConfigByProjectIdResponseSuccess = putV1ConfigByProjectIdResponse200 & {
  headers: Headers;
};
export type putV1ConfigByProjectIdResponseError = (
  | putV1ConfigByProjectIdResponse401
  | putV1ConfigByProjectIdResponse403
) & {
  headers: Headers;
};

export type putV1ConfigByProjectIdResponse =
  | putV1ConfigByProjectIdResponseSuccess
  | putV1ConfigByProjectIdResponseError;

export const getPutV1ConfigByProjectIdUrl = (projectId: string) => {
  return `http://localhost:8787/v1/config/${projectId}`;
};

export const putV1ConfigByProjectId = async (
  projectId: string,
  putV1ConfigByProjectIdBody: PutV1ConfigByProjectIdBody,
  options?: RequestInit,
): Promise<putV1ConfigByProjectIdResponse> => {
  const res = await fetch(getPutV1ConfigByProjectIdUrl(projectId), {
    ...options,
    method: "PUT",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(putV1ConfigByProjectIdBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: putV1ConfigByProjectIdResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as putV1ConfigByProjectIdResponse;
};

/**
 * Retrieve a list of all project IDs.
 * @summary List all projects
 */
export type getV1ProjectsResponse200 = {
  data: string[];
  status: 200;
};

export type getV1ProjectsResponseSuccess = getV1ProjectsResponse200 & {
  headers: Headers;
};

export type getV1ProjectsResponse = getV1ProjectsResponseSuccess;

export const getGetV1ProjectsUrl = () => {
  return `http://localhost:8787/v1/projects`;
};

export const getV1Projects = async (options?: RequestInit): Promise<getV1ProjectsResponse> => {
  const res = await fetch(getGetV1ProjectsUrl(), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getV1ProjectsResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getV1ProjectsResponse;
};

/**
 * Retrieve all streams for a specific project with their metadata.
 * @summary List streams in a project
 */
export type getV1ProjectsByProjectIdStreamsResponse200 = {
  data: [GetV1ProjectsByProjectIdStreams200Item0];
  status: 200;
};

export type getV1ProjectsByProjectIdStreamsResponseSuccess =
  getV1ProjectsByProjectIdStreamsResponse200 & {
    headers: Headers;
  };

export type getV1ProjectsByProjectIdStreamsResponse =
  getV1ProjectsByProjectIdStreamsResponseSuccess;

export const getGetV1ProjectsByProjectIdStreamsUrl = (projectId: string) => {
  return `http://localhost:8787/v1/projects/${projectId}/streams`;
};

export const getV1ProjectsByProjectIdStreams = async (
  projectId: string,
  options?: RequestInit,
): Promise<getV1ProjectsByProjectIdStreamsResponse> => {
  const res = await fetch(getGetV1ProjectsByProjectIdStreamsUrl(projectId), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getV1ProjectsByProjectIdStreamsResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getV1ProjectsByProjectIdStreamsResponse;
};

/**
 * Get detailed metadata about a stream including tail offset, content type, and TTL information.
 * @summary Inspect stream metadata
 */
export type getV1StreamsByStreamIdInspectResponse200 = {
  data: GetV1StreamsByStreamIdInspect200;
  status: 200;
};

export type getV1StreamsByStreamIdInspectResponse404 = {
  data: GetV1StreamsByStreamIdInspect404;
  status: 404;
};

export type getV1StreamsByStreamIdInspectResponseSuccess =
  getV1StreamsByStreamIdInspectResponse200 & {
    headers: Headers;
  };
export type getV1StreamsByStreamIdInspectResponseError =
  getV1StreamsByStreamIdInspectResponse404 & {
    headers: Headers;
  };

export type getV1StreamsByStreamIdInspectResponse =
  | getV1StreamsByStreamIdInspectResponseSuccess
  | getV1StreamsByStreamIdInspectResponseError;

export const getGetV1StreamsByStreamIdInspectUrl = (streamId: string) => {
  return `http://localhost:8787/v1/streams/${streamId}/inspect`;
};

export const getV1StreamsByStreamIdInspect = async (
  streamId: string,
  options?: RequestInit,
): Promise<getV1StreamsByStreamIdInspectResponse> => {
  const res = await fetch(getGetV1StreamsByStreamIdInspectUrl(streamId), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getV1StreamsByStreamIdInspectResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as getV1StreamsByStreamIdInspectResponse;
};

/**
 * Subscribe an estuary to a source stream. Messages published to the source are fan-out replicated to the estuary stream.
 * @summary Subscribe estuary to a stream
 */
export type postV1EstuarySubscribeByEstuaryPathResponse200 = {
  data: PostV1EstuarySubscribeByEstuaryPath200;
  status: 200;
};

export type postV1EstuarySubscribeByEstuaryPathResponseSuccess =
  postV1EstuarySubscribeByEstuaryPathResponse200 & {
    headers: Headers;
  };

export type postV1EstuarySubscribeByEstuaryPathResponse =
  postV1EstuarySubscribeByEstuaryPathResponseSuccess;

export const getPostV1EstuarySubscribeByEstuaryPathUrl = (estuaryPath: string) => {
  return `http://localhost:8787/v1/estuary/subscribe/${estuaryPath}`;
};

export const postV1EstuarySubscribeByEstuaryPath = async (
  estuaryPath: string,
  postV1EstuarySubscribeByEstuaryPathBody: PostV1EstuarySubscribeByEstuaryPathBody,
  options?: RequestInit,
): Promise<postV1EstuarySubscribeByEstuaryPathResponse> => {
  const res = await fetch(getPostV1EstuarySubscribeByEstuaryPathUrl(estuaryPath), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(postV1EstuarySubscribeByEstuaryPathBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postV1EstuarySubscribeByEstuaryPathResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as postV1EstuarySubscribeByEstuaryPathResponse;
};

/**
 * Remove an estuary's subscription to a source stream.
 * @summary Unsubscribe estuary from a stream
 */
export type deleteV1EstuarySubscribeByEstuaryPathResponse200 = {
  data: DeleteV1EstuarySubscribeByEstuaryPath200;
  status: 200;
};

export type deleteV1EstuarySubscribeByEstuaryPathResponseSuccess =
  deleteV1EstuarySubscribeByEstuaryPathResponse200 & {
    headers: Headers;
  };

export type deleteV1EstuarySubscribeByEstuaryPathResponse =
  deleteV1EstuarySubscribeByEstuaryPathResponseSuccess;

export const getDeleteV1EstuarySubscribeByEstuaryPathUrl = (estuaryPath: string) => {
  return `http://localhost:8787/v1/estuary/subscribe/${estuaryPath}`;
};

export const deleteV1EstuarySubscribeByEstuaryPath = async (
  estuaryPath: string,
  deleteV1EstuarySubscribeByEstuaryPathBody: DeleteV1EstuarySubscribeByEstuaryPathBody,
  options?: RequestInit,
): Promise<deleteV1EstuarySubscribeByEstuaryPathResponse> => {
  const res = await fetch(getDeleteV1EstuarySubscribeByEstuaryPathUrl(estuaryPath), {
    ...options,
    method: "DELETE",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(deleteV1EstuarySubscribeByEstuaryPathBody),
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteV1EstuarySubscribeByEstuaryPathResponse["data"] = body ? JSON.parse(body) : {};
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as deleteV1EstuarySubscribeByEstuaryPathResponse;
};

/**
 * Retrieve estuary metadata including subscriptions and content type.
 * @summary Get estuary info
 */
export type getV1EstuaryByEstuaryPathResponse200 = {
  data: GetV1EstuaryByEstuaryPath200;
  status: 200;
};

export type getV1EstuaryByEstuaryPathResponseSuccess = getV1EstuaryByEstuaryPathResponse200 & {
  headers: Headers;
};

export type getV1EstuaryByEstuaryPathResponse = getV1EstuaryByEstuaryPathResponseSuccess;

export const getGetV1EstuaryByEstuaryPathUrl = (estuaryPath: string) => {
  return `http://localhost:8787/v1/estuary/${estuaryPath}`;
};

export const getV1EstuaryByEstuaryPath = async (
  estuaryPath: string,
  options?: RequestInit,
): Promise<getV1EstuaryByEstuaryPathResponse> => {
  const res = await fetch(getGetV1EstuaryByEstuaryPathUrl(estuaryPath), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getV1EstuaryByEstuaryPathResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getV1EstuaryByEstuaryPathResponse;
};

/**
 * Delete an estuary and its underlying stream.
 * @summary Delete estuary
 */
export type deleteV1EstuaryByEstuaryPathResponse200 = {
  data: DeleteV1EstuaryByEstuaryPath200;
  status: 200;
};

export type deleteV1EstuaryByEstuaryPathResponseSuccess =
  deleteV1EstuaryByEstuaryPathResponse200 & {
    headers: Headers;
  };

export type deleteV1EstuaryByEstuaryPathResponse = deleteV1EstuaryByEstuaryPathResponseSuccess;

export const getDeleteV1EstuaryByEstuaryPathUrl = (estuaryPath: string) => {
  return `http://localhost:8787/v1/estuary/${estuaryPath}`;
};

export const deleteV1EstuaryByEstuaryPath = async (
  estuaryPath: string,
  options?: RequestInit,
): Promise<deleteV1EstuaryByEstuaryPathResponse> => {
  const res = await fetch(getDeleteV1EstuaryByEstuaryPathUrl(estuaryPath), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteV1EstuaryByEstuaryPathResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as deleteV1EstuaryByEstuaryPathResponse;
};

/**
 * Create a new append-only stream. The Content-Type header sets the stream's content type.
 * @summary Create a stream
 */
export type putV1StreamByStreamPathResponse201 = {
  data: void;
  status: 201;
};

export type putV1StreamByStreamPathResponse409 = {
  data: PutV1StreamByStreamPath409;
  status: 409;
};

export type putV1StreamByStreamPathResponseSuccess = putV1StreamByStreamPathResponse201 & {
  headers: Headers;
};
export type putV1StreamByStreamPathResponseError = putV1StreamByStreamPathResponse409 & {
  headers: Headers;
};

export type putV1StreamByStreamPathResponse =
  | putV1StreamByStreamPathResponseSuccess
  | putV1StreamByStreamPathResponseError;

export const getPutV1StreamByStreamPathUrl = (streamPath: string) => {
  return `http://localhost:8787/v1/stream/${streamPath}`;
};

export const putV1StreamByStreamPath = async (
  streamPath: string,
  options?: RequestInit,
): Promise<putV1StreamByStreamPathResponse> => {
  const res = await fetch(getPutV1StreamByStreamPathUrl(streamPath), {
    ...options,
    method: "PUT",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: putV1StreamByStreamPathResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as putV1StreamByStreamPathResponse;
};

/**
 * Append one or more messages to an existing stream. Content-Type must match the stream's content type.
 * @summary Append to a stream
 */
export type postV1StreamByStreamPathResponse200 = {
  data: void;
  status: 200;
};

export type postV1StreamByStreamPathResponse204 = {
  data: void;
  status: 204;
};

export type postV1StreamByStreamPathResponse404 = {
  data: PostV1StreamByStreamPath404;
  status: 404;
};

export type postV1StreamByStreamPathResponse409 = {
  data: PostV1StreamByStreamPath409;
  status: 409;
};

export type postV1StreamByStreamPathResponse413 = {
  data: PostV1StreamByStreamPath413;
  status: 413;
};

export type postV1StreamByStreamPathResponseSuccess = (
  | postV1StreamByStreamPathResponse200
  | postV1StreamByStreamPathResponse204
) & {
  headers: Headers;
};
export type postV1StreamByStreamPathResponseError = (
  | postV1StreamByStreamPathResponse404
  | postV1StreamByStreamPathResponse409
  | postV1StreamByStreamPathResponse413
) & {
  headers: Headers;
};

export type postV1StreamByStreamPathResponse =
  | postV1StreamByStreamPathResponseSuccess
  | postV1StreamByStreamPathResponseError;

export const getPostV1StreamByStreamPathUrl = (streamPath: string) => {
  return `http://localhost:8787/v1/stream/${streamPath}`;
};

export const postV1StreamByStreamPath = async (
  streamPath: string,
  options?: RequestInit,
): Promise<postV1StreamByStreamPathResponse> => {
  const res = await fetch(getPostV1StreamByStreamPathUrl(streamPath), {
    ...options,
    method: "POST",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: postV1StreamByStreamPathResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as postV1StreamByStreamPathResponse;
};

/**
 * Read messages from a stream. Supports offset/cursor query params, long-poll (Prefer: wait=N), SSE (Accept: text/event-stream), and WebSocket (Upgrade: websocket).
 * @summary Read from a stream
 */
export type getV1StreamByStreamPathResponse200 = {
  data: void;
  status: 200;
};

export type getV1StreamByStreamPathResponse304 = {
  data: void;
  status: 304;
};

export type getV1StreamByStreamPathResponse404 = {
  data: GetV1StreamByStreamPath404;
  status: 404;
};

export type getV1StreamByStreamPathResponseSuccess = getV1StreamByStreamPathResponse200 & {
  headers: Headers;
};
export type getV1StreamByStreamPathResponseError = (
  | getV1StreamByStreamPathResponse304
  | getV1StreamByStreamPathResponse404
) & {
  headers: Headers;
};

export type getV1StreamByStreamPathResponse =
  | getV1StreamByStreamPathResponseSuccess
  | getV1StreamByStreamPathResponseError;

export const getGetV1StreamByStreamPathUrl = (streamPath: string) => {
  return `http://localhost:8787/v1/stream/${streamPath}`;
};

export const getV1StreamByStreamPath = async (
  streamPath: string,
  options?: RequestInit,
): Promise<getV1StreamByStreamPathResponse> => {
  const res = await fetch(getGetV1StreamByStreamPathUrl(streamPath), {
    ...options,
    method: "GET",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: getV1StreamByStreamPathResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as getV1StreamByStreamPathResponse;
};

/**
 * Permanently delete a stream and all its data.
 * @summary Delete a stream
 */
export type deleteV1StreamByStreamPathResponse204 = {
  data: void;
  status: 204;
};

export type deleteV1StreamByStreamPathResponse404 = {
  data: DeleteV1StreamByStreamPath404;
  status: 404;
};

export type deleteV1StreamByStreamPathResponseSuccess = deleteV1StreamByStreamPathResponse204 & {
  headers: Headers;
};
export type deleteV1StreamByStreamPathResponseError = deleteV1StreamByStreamPathResponse404 & {
  headers: Headers;
};

export type deleteV1StreamByStreamPathResponse =
  | deleteV1StreamByStreamPathResponseSuccess
  | deleteV1StreamByStreamPathResponseError;

export const getDeleteV1StreamByStreamPathUrl = (streamPath: string) => {
  return `http://localhost:8787/v1/stream/${streamPath}`;
};

export const deleteV1StreamByStreamPath = async (
  streamPath: string,
  options?: RequestInit,
): Promise<deleteV1StreamByStreamPathResponse> => {
  const res = await fetch(getDeleteV1StreamByStreamPathUrl(streamPath), {
    ...options,
    method: "DELETE",
  });

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();

  const data: deleteV1StreamByStreamPathResponse["data"] = body ? JSON.parse(body) : {};
  return { data, status: res.status, headers: res.headers } as deleteV1StreamByStreamPathResponse;
};
