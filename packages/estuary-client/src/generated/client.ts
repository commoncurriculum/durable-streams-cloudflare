/**
 * Generated by orval v7.21.0 üç∫
 * Do not edit manually.
 * Durable Streams API
 * Durable Streams on Cloudflare ‚Äî append-only event streams with pub/sub fan-out.
 * OpenAPI spec version: 0.8.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { customFetch } from "../custom-fetch";
import type { ErrorType } from "../custom-fetch";
export type GetV1ConfigByProjectId200 = {
  corsOrigins: string[];
  isPublic: boolean;
  signingSecrets: string[];
};

export type GetV1ConfigByProjectId401Code =
  (typeof GetV1ConfigByProjectId401Code)[keyof typeof GetV1ConfigByProjectId401Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1ConfigByProjectId401Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1ConfigByProjectId401 = {
  code: GetV1ConfigByProjectId401Code;
  error: string;
};

export type GetV1ConfigByProjectId403Code =
  (typeof GetV1ConfigByProjectId403Code)[keyof typeof GetV1ConfigByProjectId403Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1ConfigByProjectId403Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1ConfigByProjectId403 = {
  code: GetV1ConfigByProjectId403Code;
  error: string;
};

export type GetV1ConfigByProjectId404Code =
  (typeof GetV1ConfigByProjectId404Code)[keyof typeof GetV1ConfigByProjectId404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1ConfigByProjectId404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1ConfigByProjectId404 = {
  code: GetV1ConfigByProjectId404Code;
  error: string;
};

export type PutV1ConfigByProjectIdBody = {
  /** @minItems 1 */
  signingSecrets: string[];
  corsOrigins?: string[];
  isPublic?: boolean;
};

export type PutV1ConfigByProjectId200 = {
  ok: boolean;
};

export type PutV1ConfigByProjectId401Code =
  (typeof PutV1ConfigByProjectId401Code)[keyof typeof PutV1ConfigByProjectId401Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutV1ConfigByProjectId401Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PutV1ConfigByProjectId401 = {
  code: PutV1ConfigByProjectId401Code;
  error: string;
};

export type PutV1ConfigByProjectId403Code =
  (typeof PutV1ConfigByProjectId403Code)[keyof typeof PutV1ConfigByProjectId403Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutV1ConfigByProjectId403Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PutV1ConfigByProjectId403 = {
  code: PutV1ConfigByProjectId403Code;
  error: string;
};

export type GetV1ProjectsByProjectIdStreams200Item0 = {
  createdAt: number;
  streamId: string;
};

export type GetV1StreamsByStreamIdInspect200 = {
  closed: boolean;
  contentType: string;
  public: boolean;
  streamId: string;
  tailOffset: number;
  closedAt?: number;
  createdAt?: number;
  expiresAt?: number;
  ttlSeconds?: number;
};

export type GetV1StreamsByStreamIdInspect404Code =
  (typeof GetV1StreamsByStreamIdInspect404Code)[keyof typeof GetV1StreamsByStreamIdInspect404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1StreamsByStreamIdInspect404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1StreamsByStreamIdInspect404 = {
  code: GetV1StreamsByStreamIdInspect404Code;
  error: string;
};

export type PostV1EstuarySubscribeByEstuaryPathBody = {
  /** @minLength 1 */
  estuaryId: string;
};

export type PostV1EstuarySubscribeByEstuaryPath200 = {
  estuaryId: string;
  estuaryStreamPath: string;
  expiresAt: number;
  isNewEstuary: boolean;
  streamId: string;
};

export type DeleteV1EstuarySubscribeByEstuaryPathBody = {
  /** @minLength 1 */
  estuaryId: string;
};

export type DeleteV1EstuarySubscribeByEstuaryPath200 = {
  success: "true";
};

export type GetV1EstuaryByEstuaryPath200ContentType = string | null;

export type GetV1EstuaryByEstuaryPath200SubscriptionsItem = {
  streamId: string;
};

export type GetV1EstuaryByEstuaryPath200 = {
  contentType: GetV1EstuaryByEstuaryPath200ContentType;
  estuaryId: string;
  estuaryStreamPath: string;
  subscriptions: GetV1EstuaryByEstuaryPath200SubscriptionsItem[];
};

export type DeleteV1EstuaryByEstuaryPath200 = {
  deleted: "true";
  estuaryId: string;
};

export type PutV1StreamByStreamPath409Code =
  (typeof PutV1StreamByStreamPath409Code)[keyof typeof PutV1StreamByStreamPath409Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PutV1StreamByStreamPath409Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PutV1StreamByStreamPath409 = {
  code: PutV1StreamByStreamPath409Code;
  error: string;
};

export type PostV1StreamByStreamPath404Code =
  (typeof PostV1StreamByStreamPath404Code)[keyof typeof PostV1StreamByStreamPath404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostV1StreamByStreamPath404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PostV1StreamByStreamPath404 = {
  code: PostV1StreamByStreamPath404Code;
  error: string;
};

export type PostV1StreamByStreamPath409Code =
  (typeof PostV1StreamByStreamPath409Code)[keyof typeof PostV1StreamByStreamPath409Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostV1StreamByStreamPath409Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PostV1StreamByStreamPath409 = {
  code: PostV1StreamByStreamPath409Code;
  error: string;
};

export type PostV1StreamByStreamPath413Code =
  (typeof PostV1StreamByStreamPath413Code)[keyof typeof PostV1StreamByStreamPath413Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PostV1StreamByStreamPath413Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type PostV1StreamByStreamPath413 = {
  code: PostV1StreamByStreamPath413Code;
  error: string;
};

export type GetV1StreamByStreamPath404Code =
  (typeof GetV1StreamByStreamPath404Code)[keyof typeof GetV1StreamByStreamPath404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetV1StreamByStreamPath404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type GetV1StreamByStreamPath404 = {
  code: GetV1StreamByStreamPath404Code;
  error: string;
};

export type DeleteV1StreamByStreamPath404Code =
  (typeof DeleteV1StreamByStreamPath404Code)[keyof typeof DeleteV1StreamByStreamPath404Code];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeleteV1StreamByStreamPath404Code = {
  BATCH_BUILD_FAILED: "BATCH_BUILD_FAILED",
  CONTENT_LENGTH_MISMATCH: "CONTENT_LENGTH_MISMATCH",
  CONTENT_TYPE_MISMATCH: "CONTENT_TYPE_MISMATCH",
  CONTENT_TYPE_REQUIRED: "CONTENT_TYPE_REQUIRED",
  EMPTY_BODY: "EMPTY_BODY",
  EMPTY_JSON_ARRAY: "EMPTY_JSON_ARRAY",
  EMPTY_QUERY_PARAM: "EMPTY_QUERY_PARAM",
  FORBIDDEN: "FORBIDDEN",
  INTERNAL_ERROR: "INTERNAL_ERROR",
  INVALID_CONTENT_LENGTH: "INVALID_CONTENT_LENGTH",
  INVALID_EXPIRES_AT: "INVALID_EXPIRES_AT",
  INVALID_JSON: "INVALID_JSON",
  INVALID_OFFSET: "INVALID_OFFSET",
  INVALID_TTL: "INVALID_TTL",
  MISSING_PROJECT_OR_STREAM_ID: "MISSING_PROJECT_OR_STREAM_ID",
  OFFSET_BEYOND_TAIL: "OFFSET_BEYOND_TAIL",
  OFFSET_REQUIRED: "OFFSET_REQUIRED",
  PAYLOAD_TOO_LARGE: "PAYLOAD_TOO_LARGE",
  PRODUCER_EPOCH_SEQ_NOT_INTEGERS: "PRODUCER_EPOCH_SEQ_NOT_INTEGERS",
  PRODUCER_EPOCH_SEQ_OVERFLOW: "PRODUCER_EPOCH_SEQ_OVERFLOW",
  PRODUCER_EVAL_FAILED: "PRODUCER_EVAL_FAILED",
  PRODUCER_HEADERS_INCOMPLETE: "PRODUCER_HEADERS_INCOMPLETE",
  PRODUCER_ID_INVALID: "PRODUCER_ID_INVALID",
  PRODUCER_SEQUENCE_GAP: "PRODUCER_SEQUENCE_GAP",
  PRODUCER_SEQ_MUST_START_AT_ZERO: "PRODUCER_SEQ_MUST_START_AT_ZERO",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  SEGMENT_MISSING: "SEGMENT_MISSING",
  SEGMENT_TRUNCATED: "SEGMENT_TRUNCATED",
  SEGMENT_UNAVAILABLE: "SEGMENT_UNAVAILABLE",
  STALE_PRODUCER_EPOCH: "STALE_PRODUCER_EPOCH",
  STORAGE_QUOTA_EXCEEDED: "STORAGE_QUOTA_EXCEEDED",
  STREAM_CLOSED: "STREAM_CLOSED",
  STREAM_CLOSED_STATUS_MISMATCH: "STREAM_CLOSED_STATUS_MISMATCH",
  STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
  STREAM_SEQ_REGRESSION: "STREAM_SEQ_REGRESSION",
  STREAM_TTL_MISMATCH: "STREAM_TTL_MISMATCH",
  TOO_MANY_SSE_CONNECTIONS: "TOO_MANY_SSE_CONNECTIONS",
  TTL_EXPIRES_MUTUALLY_EXCLUSIVE: "TTL_EXPIRES_MUTUALLY_EXCLUSIVE",
  UNAUTHORIZED: "UNAUTHORIZED",
  WEBSOCKET_UPGRADE_REQUIRED: "WEBSOCKET_UPGRADE_REQUIRED",
} as const;

export type DeleteV1StreamByStreamPath404 = {
  code: DeleteV1StreamByStreamPath404Code;
  error: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Returns 200 OK if the worker is running.
 * @summary Health check
 */
export const getHealth = (options?: SecondParameter<typeof customFetch>, signal?: AbortSignal) => {
  return customFetch<string>(
    { url: `http://localhost:8787/health`, method: "GET", signal },
    options,
  );
};

export const getGetHealthQueryKey = () => {
  return [`http://localhost:8787/health`] as const;
};

export const getGetHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHealthQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealth>>> = ({ signal }) =>
    getHealth(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getHealth>>>;
export type GetHealthQueryError = ErrorType<unknown>;

export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Health check
 */

export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetHealthQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve signing secrets, CORS origins, and public flag for a project. Requires a manage-scope JWT.
 * @summary Get project configuration
 */
export const getV1ConfigByProjectId = (
  projectId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<GetV1ConfigByProjectId200>(
    { url: `http://localhost:8787/v1/config/${projectId}`, method: "GET", signal },
    options,
  );
};

export const getGetV1ConfigByProjectIdQueryKey = (projectId?: string) => {
  return [`http://localhost:8787/v1/config/${projectId}`] as const;
};

export const getGetV1ConfigByProjectIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
  TError = ErrorType<
    GetV1ConfigByProjectId401 | GetV1ConfigByProjectId403 | GetV1ConfigByProjectId404
  >,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ConfigByProjectId>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetV1ConfigByProjectIdQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ConfigByProjectId>>> = ({ signal }) =>
    getV1ConfigByProjectId(projectId, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!projectId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetV1ConfigByProjectIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1ConfigByProjectId>>
>;
export type GetV1ConfigByProjectIdQueryError = ErrorType<
  GetV1ConfigByProjectId401 | GetV1ConfigByProjectId403 | GetV1ConfigByProjectId404
>;

export function useGetV1ConfigByProjectId<
  TData = Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
  TError = ErrorType<
    GetV1ConfigByProjectId401 | GetV1ConfigByProjectId403 | GetV1ConfigByProjectId404
  >,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ConfigByProjectId>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
          TError,
          Awaited<ReturnType<typeof getV1ConfigByProjectId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1ConfigByProjectId<
  TData = Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
  TError = ErrorType<
    GetV1ConfigByProjectId401 | GetV1ConfigByProjectId403 | GetV1ConfigByProjectId404
  >,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ConfigByProjectId>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
          TError,
          Awaited<ReturnType<typeof getV1ConfigByProjectId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1ConfigByProjectId<
  TData = Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
  TError = ErrorType<
    GetV1ConfigByProjectId401 | GetV1ConfigByProjectId403 | GetV1ConfigByProjectId404
  >,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ConfigByProjectId>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get project configuration
 */

export function useGetV1ConfigByProjectId<
  TData = Awaited<ReturnType<typeof getV1ConfigByProjectId>>,
  TError = ErrorType<
    GetV1ConfigByProjectId401 | GetV1ConfigByProjectId403 | GetV1ConfigByProjectId404
  >,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ConfigByProjectId>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1ConfigByProjectIdQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Set signing secrets, CORS origins, and public flag for a project. Requires a manage-scope JWT.
 * @summary Update project configuration
 */
export const putV1ConfigByProjectId = (
  projectId: string,
  putV1ConfigByProjectIdBody: PutV1ConfigByProjectIdBody,
  options?: SecondParameter<typeof customFetch>,
) => {
  return customFetch<PutV1ConfigByProjectId200>(
    {
      url: `http://localhost:8787/v1/config/${projectId}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: putV1ConfigByProjectIdBody,
    },
    options,
  );
};

export const getPutV1ConfigByProjectIdMutationOptions = <
  TError = ErrorType<PutV1ConfigByProjectId401 | PutV1ConfigByProjectId403>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putV1ConfigByProjectId>>,
    TError,
    { projectId: string; data: PutV1ConfigByProjectIdBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putV1ConfigByProjectId>>,
  TError,
  { projectId: string; data: PutV1ConfigByProjectIdBody },
  TContext
> => {
  const mutationKey = ["putV1ConfigByProjectId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putV1ConfigByProjectId>>,
    { projectId: string; data: PutV1ConfigByProjectIdBody }
  > = (props) => {
    const { projectId, data } = props ?? {};

    return putV1ConfigByProjectId(projectId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutV1ConfigByProjectIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof putV1ConfigByProjectId>>
>;
export type PutV1ConfigByProjectIdMutationBody = PutV1ConfigByProjectIdBody;
export type PutV1ConfigByProjectIdMutationError = ErrorType<
  PutV1ConfigByProjectId401 | PutV1ConfigByProjectId403
>;

/**
 * @summary Update project configuration
 */
export const usePutV1ConfigByProjectId = <
  TError = ErrorType<PutV1ConfigByProjectId401 | PutV1ConfigByProjectId403>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putV1ConfigByProjectId>>,
      TError,
      { projectId: string; data: PutV1ConfigByProjectIdBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putV1ConfigByProjectId>>,
  TError,
  { projectId: string; data: PutV1ConfigByProjectIdBody },
  TContext
> => {
  const mutationOptions = getPutV1ConfigByProjectIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve a list of all project IDs.
 * @summary List all projects
 */
export const getV1Projects = (
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<string[]>(
    { url: `http://localhost:8787/v1/projects`, method: "GET", signal },
    options,
  );
};

export const getGetV1ProjectsQueryKey = () => {
  return [`http://localhost:8787/v1/projects`] as const;
};

export const getGetV1ProjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1Projects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Projects>>, TError, TData>>;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetV1ProjectsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Projects>>> = ({ signal }) =>
    getV1Projects(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1Projects>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetV1ProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Projects>>>;
export type GetV1ProjectsQueryError = ErrorType<unknown>;

export function useGetV1Projects<
  TData = Awaited<ReturnType<typeof getV1Projects>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Projects>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Projects>>,
          TError,
          Awaited<ReturnType<typeof getV1Projects>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1Projects<
  TData = Awaited<ReturnType<typeof getV1Projects>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Projects>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Projects>>,
          TError,
          Awaited<ReturnType<typeof getV1Projects>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1Projects<
  TData = Awaited<ReturnType<typeof getV1Projects>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Projects>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List all projects
 */

export function useGetV1Projects<
  TData = Awaited<ReturnType<typeof getV1Projects>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Projects>>, TError, TData>>;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1ProjectsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve all streams for a specific project with their metadata.
 * @summary List streams in a project
 */
export const getV1ProjectsByProjectIdStreams = (
  projectId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<[GetV1ProjectsByProjectIdStreams200Item0]>(
    { url: `http://localhost:8787/v1/projects/${projectId}/streams`, method: "GET", signal },
    options,
  );
};

export const getGetV1ProjectsByProjectIdStreamsQueryKey = (projectId?: string) => {
  return [`http://localhost:8787/v1/projects/${projectId}/streams`] as const;
};

export const getGetV1ProjectsByProjectIdStreamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
  TError = ErrorType<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetV1ProjectsByProjectIdStreamsQueryKey(projectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>> = ({
    signal,
  }) => getV1ProjectsByProjectIdStreams(projectId, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!projectId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetV1ProjectsByProjectIdStreamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>
>;
export type GetV1ProjectsByProjectIdStreamsQueryError = ErrorType<unknown>;

export function useGetV1ProjectsByProjectIdStreams<
  TData = Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
  TError = ErrorType<unknown>,
>(
  projectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
          TError,
          Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1ProjectsByProjectIdStreams<
  TData = Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
  TError = ErrorType<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
          TError,
          Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1ProjectsByProjectIdStreams<
  TData = Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
  TError = ErrorType<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List streams in a project
 */

export function useGetV1ProjectsByProjectIdStreams<
  TData = Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>,
  TError = ErrorType<unknown>,
>(
  projectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1ProjectsByProjectIdStreams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1ProjectsByProjectIdStreamsQueryOptions(projectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get detailed metadata about a stream including tail offset, content type, and TTL information.
 * @summary Inspect stream metadata
 */
export const getV1StreamsByStreamIdInspect = (
  streamId: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<GetV1StreamsByStreamIdInspect200>(
    { url: `http://localhost:8787/v1/streams/${streamId}/inspect`, method: "GET", signal },
    options,
  );
};

export const getGetV1StreamsByStreamIdInspectQueryKey = (streamId?: string) => {
  return [`http://localhost:8787/v1/streams/${streamId}/inspect`] as const;
};

export const getGetV1StreamsByStreamIdInspectQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
  TError = ErrorType<GetV1StreamsByStreamIdInspect404>,
>(
  streamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetV1StreamsByStreamIdInspectQueryKey(streamId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>> = ({
    signal,
  }) => getV1StreamsByStreamIdInspect(streamId, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!streamId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetV1StreamsByStreamIdInspectQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>
>;
export type GetV1StreamsByStreamIdInspectQueryError = ErrorType<GetV1StreamsByStreamIdInspect404>;

export function useGetV1StreamsByStreamIdInspect<
  TData = Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
  TError = ErrorType<GetV1StreamsByStreamIdInspect404>,
>(
  streamId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
          TError,
          Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1StreamsByStreamIdInspect<
  TData = Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
  TError = ErrorType<GetV1StreamsByStreamIdInspect404>,
>(
  streamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
          TError,
          Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1StreamsByStreamIdInspect<
  TData = Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
  TError = ErrorType<GetV1StreamsByStreamIdInspect404>,
>(
  streamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Inspect stream metadata
 */

export function useGetV1StreamsByStreamIdInspect<
  TData = Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>,
  TError = ErrorType<GetV1StreamsByStreamIdInspect404>,
>(
  streamId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamsByStreamIdInspect>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1StreamsByStreamIdInspectQueryOptions(streamId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Subscribe an estuary to a source stream. Messages published to the source are fan-out replicated to the estuary stream.
 * @summary Subscribe estuary to a stream
 */
export const postV1EstuarySubscribeByEstuaryPath = (
  estuaryPath: string,
  postV1EstuarySubscribeByEstuaryPathBody: PostV1EstuarySubscribeByEstuaryPathBody,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<PostV1EstuarySubscribeByEstuaryPath200>(
    {
      url: `http://localhost:8787/v1/estuary/subscribe/${estuaryPath}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postV1EstuarySubscribeByEstuaryPathBody,
      signal,
    },
    options,
  );
};

export const getPostV1EstuarySubscribeByEstuaryPathMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1EstuarySubscribeByEstuaryPath>>,
    TError,
    { estuaryPath: string; data: PostV1EstuarySubscribeByEstuaryPathBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1EstuarySubscribeByEstuaryPath>>,
  TError,
  { estuaryPath: string; data: PostV1EstuarySubscribeByEstuaryPathBody },
  TContext
> => {
  const mutationKey = ["postV1EstuarySubscribeByEstuaryPath"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1EstuarySubscribeByEstuaryPath>>,
    { estuaryPath: string; data: PostV1EstuarySubscribeByEstuaryPathBody }
  > = (props) => {
    const { estuaryPath, data } = props ?? {};

    return postV1EstuarySubscribeByEstuaryPath(estuaryPath, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostV1EstuarySubscribeByEstuaryPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1EstuarySubscribeByEstuaryPath>>
>;
export type PostV1EstuarySubscribeByEstuaryPathMutationBody =
  PostV1EstuarySubscribeByEstuaryPathBody;
export type PostV1EstuarySubscribeByEstuaryPathMutationError = ErrorType<unknown>;

/**
 * @summary Subscribe estuary to a stream
 */
export const usePostV1EstuarySubscribeByEstuaryPath = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1EstuarySubscribeByEstuaryPath>>,
      TError,
      { estuaryPath: string; data: PostV1EstuarySubscribeByEstuaryPathBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postV1EstuarySubscribeByEstuaryPath>>,
  TError,
  { estuaryPath: string; data: PostV1EstuarySubscribeByEstuaryPathBody },
  TContext
> => {
  const mutationOptions = getPostV1EstuarySubscribeByEstuaryPathMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Remove an estuary's subscription to a source stream.
 * @summary Unsubscribe estuary from a stream
 */
export const deleteV1EstuarySubscribeByEstuaryPath = (
  estuaryPath: string,
  deleteV1EstuarySubscribeByEstuaryPathBody: DeleteV1EstuarySubscribeByEstuaryPathBody,
  options?: SecondParameter<typeof customFetch>,
) => {
  return customFetch<DeleteV1EstuarySubscribeByEstuaryPath200>(
    {
      url: `http://localhost:8787/v1/estuary/subscribe/${estuaryPath}`,
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      data: deleteV1EstuarySubscribeByEstuaryPathBody,
    },
    options,
  );
};

export const getDeleteV1EstuarySubscribeByEstuaryPathMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteV1EstuarySubscribeByEstuaryPath>>,
    TError,
    { estuaryPath: string; data: DeleteV1EstuarySubscribeByEstuaryPathBody },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteV1EstuarySubscribeByEstuaryPath>>,
  TError,
  { estuaryPath: string; data: DeleteV1EstuarySubscribeByEstuaryPathBody },
  TContext
> => {
  const mutationKey = ["deleteV1EstuarySubscribeByEstuaryPath"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteV1EstuarySubscribeByEstuaryPath>>,
    { estuaryPath: string; data: DeleteV1EstuarySubscribeByEstuaryPathBody }
  > = (props) => {
    const { estuaryPath, data } = props ?? {};

    return deleteV1EstuarySubscribeByEstuaryPath(estuaryPath, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteV1EstuarySubscribeByEstuaryPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteV1EstuarySubscribeByEstuaryPath>>
>;
export type DeleteV1EstuarySubscribeByEstuaryPathMutationBody =
  DeleteV1EstuarySubscribeByEstuaryPathBody;
export type DeleteV1EstuarySubscribeByEstuaryPathMutationError = ErrorType<unknown>;

/**
 * @summary Unsubscribe estuary from a stream
 */
export const useDeleteV1EstuarySubscribeByEstuaryPath = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteV1EstuarySubscribeByEstuaryPath>>,
      TError,
      { estuaryPath: string; data: DeleteV1EstuarySubscribeByEstuaryPathBody },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteV1EstuarySubscribeByEstuaryPath>>,
  TError,
  { estuaryPath: string; data: DeleteV1EstuarySubscribeByEstuaryPathBody },
  TContext
> => {
  const mutationOptions = getDeleteV1EstuarySubscribeByEstuaryPathMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve estuary metadata including subscriptions and content type.
 * @summary Get estuary info
 */
export const getV1EstuaryByEstuaryPath = (
  estuaryPath: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<GetV1EstuaryByEstuaryPath200>(
    { url: `http://localhost:8787/v1/estuary/${estuaryPath}`, method: "GET", signal },
    options,
  );
};

export const getGetV1EstuaryByEstuaryPathQueryKey = (estuaryPath?: string) => {
  return [`http://localhost:8787/v1/estuary/${estuaryPath}`] as const;
};

export const getGetV1EstuaryByEstuaryPathQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
  TError = ErrorType<unknown>,
>(
  estuaryPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetV1EstuaryByEstuaryPathQueryKey(estuaryPath);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>> = ({
    signal,
  }) => getV1EstuaryByEstuaryPath(estuaryPath, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!estuaryPath, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetV1EstuaryByEstuaryPathQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>
>;
export type GetV1EstuaryByEstuaryPathQueryError = ErrorType<unknown>;

export function useGetV1EstuaryByEstuaryPath<
  TData = Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
  TError = ErrorType<unknown>,
>(
  estuaryPath: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
          TError,
          Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1EstuaryByEstuaryPath<
  TData = Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
  TError = ErrorType<unknown>,
>(
  estuaryPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
          TError,
          Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1EstuaryByEstuaryPath<
  TData = Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
  TError = ErrorType<unknown>,
>(
  estuaryPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get estuary info
 */

export function useGetV1EstuaryByEstuaryPath<
  TData = Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>,
  TError = ErrorType<unknown>,
>(
  estuaryPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1EstuaryByEstuaryPath>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1EstuaryByEstuaryPathQueryOptions(estuaryPath, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Delete an estuary and its underlying stream.
 * @summary Delete estuary
 */
export const deleteV1EstuaryByEstuaryPath = (
  estuaryPath: string,
  options?: SecondParameter<typeof customFetch>,
) => {
  return customFetch<DeleteV1EstuaryByEstuaryPath200>(
    { url: `http://localhost:8787/v1/estuary/${estuaryPath}`, method: "DELETE" },
    options,
  );
};

export const getDeleteV1EstuaryByEstuaryPathMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteV1EstuaryByEstuaryPath>>,
    TError,
    { estuaryPath: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteV1EstuaryByEstuaryPath>>,
  TError,
  { estuaryPath: string },
  TContext
> => {
  const mutationKey = ["deleteV1EstuaryByEstuaryPath"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteV1EstuaryByEstuaryPath>>,
    { estuaryPath: string }
  > = (props) => {
    const { estuaryPath } = props ?? {};

    return deleteV1EstuaryByEstuaryPath(estuaryPath, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteV1EstuaryByEstuaryPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteV1EstuaryByEstuaryPath>>
>;

export type DeleteV1EstuaryByEstuaryPathMutationError = ErrorType<unknown>;

/**
 * @summary Delete estuary
 */
export const useDeleteV1EstuaryByEstuaryPath = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteV1EstuaryByEstuaryPath>>,
      TError,
      { estuaryPath: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteV1EstuaryByEstuaryPath>>,
  TError,
  { estuaryPath: string },
  TContext
> => {
  const mutationOptions = getDeleteV1EstuaryByEstuaryPathMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new append-only stream. The Content-Type header sets the stream's content type.
 * @summary Create a stream
 */
export const putV1StreamByStreamPath = (
  streamPath: string,
  options?: SecondParameter<typeof customFetch>,
) => {
  return customFetch<void>(
    { url: `http://localhost:8787/v1/stream/${streamPath}`, method: "PUT" },
    options,
  );
};

export const getPutV1StreamByStreamPathMutationOptions = <
  TError = ErrorType<PutV1StreamByStreamPath409>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putV1StreamByStreamPath>>,
    TError,
    { streamPath: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putV1StreamByStreamPath>>,
  TError,
  { streamPath: string },
  TContext
> => {
  const mutationKey = ["putV1StreamByStreamPath"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putV1StreamByStreamPath>>,
    { streamPath: string }
  > = (props) => {
    const { streamPath } = props ?? {};

    return putV1StreamByStreamPath(streamPath, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutV1StreamByStreamPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof putV1StreamByStreamPath>>
>;

export type PutV1StreamByStreamPathMutationError = ErrorType<PutV1StreamByStreamPath409>;

/**
 * @summary Create a stream
 */
export const usePutV1StreamByStreamPath = <
  TError = ErrorType<PutV1StreamByStreamPath409>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putV1StreamByStreamPath>>,
      TError,
      { streamPath: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putV1StreamByStreamPath>>,
  TError,
  { streamPath: string },
  TContext
> => {
  const mutationOptions = getPutV1StreamByStreamPathMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Append one or more messages to an existing stream. Content-Type must match the stream's content type.
 * @summary Append to a stream
 */
export const postV1StreamByStreamPath = (
  streamPath: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<void | void>(
    { url: `http://localhost:8787/v1/stream/${streamPath}`, method: "POST", signal },
    options,
  );
};

export const getPostV1StreamByStreamPathMutationOptions = <
  TError = ErrorType<
    PostV1StreamByStreamPath404 | PostV1StreamByStreamPath409 | PostV1StreamByStreamPath413
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postV1StreamByStreamPath>>,
    TError,
    { streamPath: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postV1StreamByStreamPath>>,
  TError,
  { streamPath: string },
  TContext
> => {
  const mutationKey = ["postV1StreamByStreamPath"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postV1StreamByStreamPath>>,
    { streamPath: string }
  > = (props) => {
    const { streamPath } = props ?? {};

    return postV1StreamByStreamPath(streamPath, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostV1StreamByStreamPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof postV1StreamByStreamPath>>
>;

export type PostV1StreamByStreamPathMutationError = ErrorType<
  PostV1StreamByStreamPath404 | PostV1StreamByStreamPath409 | PostV1StreamByStreamPath413
>;

/**
 * @summary Append to a stream
 */
export const usePostV1StreamByStreamPath = <
  TError = ErrorType<
    PostV1StreamByStreamPath404 | PostV1StreamByStreamPath409 | PostV1StreamByStreamPath413
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postV1StreamByStreamPath>>,
      TError,
      { streamPath: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postV1StreamByStreamPath>>,
  TError,
  { streamPath: string },
  TContext
> => {
  const mutationOptions = getPostV1StreamByStreamPathMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Read messages from a stream. Supports offset/cursor query params, long-poll (Prefer: wait=N), SSE (Accept: text/event-stream), and WebSocket (Upgrade: websocket).
 * @summary Read from a stream
 */
export const getV1StreamByStreamPath = (
  streamPath: string,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal,
) => {
  return customFetch<void>(
    { url: `http://localhost:8787/v1/stream/${streamPath}`, method: "GET", signal },
    options,
  );
};

export const getGetV1StreamByStreamPathQueryKey = (streamPath?: string) => {
  return [`http://localhost:8787/v1/stream/${streamPath}`] as const;
};

export const getGetV1StreamByStreamPathQueryOptions = <
  TData = Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
  TError = ErrorType<void | GetV1StreamByStreamPath404>,
>(
  streamPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamByStreamPath>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetV1StreamByStreamPathQueryKey(streamPath);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1StreamByStreamPath>>> = ({
    signal,
  }) => getV1StreamByStreamPath(streamPath, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!streamPath, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetV1StreamByStreamPathQueryResult = NonNullable<
  Awaited<ReturnType<typeof getV1StreamByStreamPath>>
>;
export type GetV1StreamByStreamPathQueryError = ErrorType<void | GetV1StreamByStreamPath404>;

export function useGetV1StreamByStreamPath<
  TData = Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
  TError = ErrorType<void | GetV1StreamByStreamPath404>,
>(
  streamPath: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamByStreamPath>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
          TError,
          Awaited<ReturnType<typeof getV1StreamByStreamPath>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1StreamByStreamPath<
  TData = Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
  TError = ErrorType<void | GetV1StreamByStreamPath404>,
>(
  streamPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamByStreamPath>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
          TError,
          Awaited<ReturnType<typeof getV1StreamByStreamPath>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetV1StreamByStreamPath<
  TData = Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
  TError = ErrorType<void | GetV1StreamByStreamPath404>,
>(
  streamPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamByStreamPath>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Read from a stream
 */

export function useGetV1StreamByStreamPath<
  TData = Awaited<ReturnType<typeof getV1StreamByStreamPath>>,
  TError = ErrorType<void | GetV1StreamByStreamPath404>,
>(
  streamPath: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getV1StreamByStreamPath>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetV1StreamByStreamPathQueryOptions(streamPath, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Permanently delete a stream and all its data.
 * @summary Delete a stream
 */
export const deleteV1StreamByStreamPath = (
  streamPath: string,
  options?: SecondParameter<typeof customFetch>,
) => {
  return customFetch<void>(
    { url: `http://localhost:8787/v1/stream/${streamPath}`, method: "DELETE" },
    options,
  );
};

export const getDeleteV1StreamByStreamPathMutationOptions = <
  TError = ErrorType<DeleteV1StreamByStreamPath404>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteV1StreamByStreamPath>>,
    TError,
    { streamPath: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteV1StreamByStreamPath>>,
  TError,
  { streamPath: string },
  TContext
> => {
  const mutationKey = ["deleteV1StreamByStreamPath"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteV1StreamByStreamPath>>,
    { streamPath: string }
  > = (props) => {
    const { streamPath } = props ?? {};

    return deleteV1StreamByStreamPath(streamPath, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteV1StreamByStreamPathMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteV1StreamByStreamPath>>
>;

export type DeleteV1StreamByStreamPathMutationError = ErrorType<DeleteV1StreamByStreamPath404>;

/**
 * @summary Delete a stream
 */
export const useDeleteV1StreamByStreamPath = <
  TError = ErrorType<DeleteV1StreamByStreamPath404>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteV1StreamByStreamPath>>,
      TError,
      { streamPath: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteV1StreamByStreamPath>>,
  TError,
  { streamPath: string },
  TContext
> => {
  const mutationOptions = getDeleteV1StreamByStreamPathMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
